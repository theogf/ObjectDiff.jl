var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StructDiff","category":"page"},{"location":"#StructDiff","page":"Home","title":"StructDiff","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StructDiff.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StructDiff]","category":"page"},{"location":"#StructDiff.AbstractDiff","page":"Home","title":"StructDiff.AbstractDiff","text":"General abstract representation of a difference between two objects. Any AbstractDiff type should implement the following:\n\nprintdiff(::IO, ::AbstractDiff) \nnodiff(::AbstractDiff)::Bool whether there are differences to consider.\n\nOptionally you can implement:\n\nxcolor::Symbol color of the left object (default :blue).\nycolor::Symbol color of the right object (default :yellow).\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.ArrayDiff","page":"Home","title":"StructDiff.ArrayDiff","text":"Collection of array element differences.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.AtomicDiff","page":"Home","title":"StructDiff.AtomicDiff","text":"An AtomicDiff is a leaf in the diff tree, i.e. it does not have any children differences. AtomicDiff subtypes should implement:\n\nBase.first(::AtomicDiff): the left element\nBase.last(::AtomicDiff): the right element\n\nSubtypes can also implement the diff_prefix(::IO, ::AtomicDiff) to print some additional prefix.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.BitsDiff","page":"Home","title":"StructDiff.BitsDiff","text":"Basic representation of different objects, also used as a fallback.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.DictDiff","page":"Home","title":"StructDiff.DictDiff","text":"Collection of comparison of (key, value) pairs.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.DiffCollection","page":"Home","title":"StructDiff.DiffCollection","text":"As opposed to AtomicDiff, DiffCollection contains multiple diff objects.\n\nYou should implement vals(::DiffCollection) to return the unfiltered collection of diff elements. Note that it defaults to getproperty(::DiffCollection, :diffs).\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.FieldsDiff","page":"Home","title":"StructDiff.FieldsDiff","text":"Collection of fields differences, usually comes from comparing struct.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.NamedDiff","page":"Home","title":"StructDiff.NamedDiff","text":"Difference with a specific name indicator. The key can be of all types.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.SizeDiff","page":"Home","title":"StructDiff.SizeDiff","text":"Representation of different sizes.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.TypeDiff","page":"Home","title":"StructDiff.TypeDiff","text":"Representation of different types.\n\n\n\n\n\n","category":"type"},{"location":"#StructDiff.compare-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2}","page":"Home","title":"StructDiff.compare","text":"compare(x, y) -> AbstractDiff\n\nMain functionality of the package. Takes two argument and build a comparison tree that recursively checks different aspects of the compared objects. The obtained object can be checked for equality with nodiff.\n\n\n\n\n\n","category":"method"},{"location":"#StructDiff.nodiff-Tuple{StructDiff.AbstractDiff}","page":"Home","title":"StructDiff.nodiff","text":"Indicates if the given AbstractDiff object contains actual differences.\n\n\n\n\n\n","category":"method"},{"location":"#StructDiff.@test_diff-Tuple{Any, Vararg{Any}}","page":"Home","title":"StructDiff.@test_diff","text":"Equivalent to the @test macro, that will print the difference tree if @test_diff is called on an equality call.\n\n\n\n\n\n","category":"macro"}]
}
